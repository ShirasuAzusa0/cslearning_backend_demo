## 📦 Fiber

## 新建[](#new "直接链接到新建")

此方法创建一个新的 **App** 名为实例。在创建新实例时，你可以传递可选的 [config](#config) 。

签名

```go
func New(config ...Config) *App
```

示例

```go
// Default configapp := fiber.New()// ...
```

## 配置[](#config "直接链接到配置")

在创建新的 Fiber 实例时，你可以传递一个可选的 Config。

示例

```go
// Custom configapp := fiber.New(fiber.Config{    Prefork:       true,    CaseSensitive: true,    StrictRouting: true,    ServerHeader:  "Fiber",    AppName: "Test App v1.0.1",})// ...
```

**配置字段**

| 属性                                                         | 类型                                                         | 描述                                                         | 默认                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| AppName                                                      | `字符串`                                                     | 这允许为应用程序设置应用程序名称                             | `""`                                                         |
| BodyLimit                                                    | `整数`                                                       | 设置请求正文的最大允许大小，如果大小超过配置的限制，它会发送 `413 - 请求实体太大` 响应。 | `4 * 1024 * 1024`                                            |
| CaseSensitive                                                | `布尔值`                                                     | 启用后，`/Foo` 和 `/foo` 是不同的路由。禁用后，`/Foo` 和 `/foo` 被视为相同。 | `false`                                                      |
| ColorScheme                                                  | [`颜色`](https://github.com/gofiber/fiber/blob/master/color.go) | 您可以定义自定义配色方案。它们将用于启动消息、路由列表和一些中间件。 | [`默认颜色`](https://github.com/gofiber/fiber/blob/master/color.go) |
| 压缩文件后缀                                                 | `字符串`                                                     | 向原始文件名添加后缀，并尝试使用新文件名保存生成的压缩文件。 | `".fiber.gz"`                                                |
| 并发                                                         | `整数`                                                       | 最大并发连接数。                                             | `256 * 1024`                                                 |
| 禁用默认内容类型                                             | `布尔值`                                                     | 如果设置为 true，则默认 Content-Type 头将从响应中排除。      | `false`                                                      |
| 禁用默认日期                                                 | `布尔值`                                                     | 如果设置为 true，则默认日期头将从响应中排除。                | `false`                                                      |
| 禁用头标准化                                                 | `布尔值`                                                     | 默认情况下，所有头名称都已标准化：conteNT-tYPE -> Content-Type | `false`                                                      |
| 禁用保持活动连接                                             | `布尔值`                                                     | 禁用保持活动连接，服务器在向客户端发送第一个响应后将关闭传入连接 | `false`                                                      |
| 禁用预解析多部分表单                                         | `布尔值`                                                     | 如果设置为 true，则不会预解析多部分表单数据。此选项对于希望将多部分表单数据视为二进制 blob 或选择何时解析数据的服务器很有用。 | `false`                                                      |
| 禁用启动消息                                                 | `布尔值`                                                     | 如果设置为 true，则不会打印出调试信息                        | `false`                                                      |
| ETag                                                         | `布尔值`                                                     | 启用或禁用 ETag 头生成，因为弱 ETag 和强 ETag 都使用相同哈希方法 (CRC-32) 生成。启用时，弱 ETag 是默认值。 | `false`                                                      |
| 启用 IP 验证                                                 | `布尔值`                                                     | 如果设置为 true，则 `c.IP()` 和 `c.IPs()` 将在返回 IP 地址之前对其进行验证。此外，`c.IP()` 将仅返回第一个有效的 IP，而不是可能用逗号分隔的字符串的原始头值。 |                                                              |
| **警告：**执行此验证会产生少量性能开销。如果速度是您唯一关心的问题，并且您的应用程序位于已经验证此头的受信任代理之后，请保持禁用状态。 |                                                              |                                                              |                                                              |

 | `false` |
| 启用打印路由 | `布尔值` | 启用打印路由可启用打印所有路由及其方法、路径、名称和处理程序。 | `false` |
| 启用在解析器上拆分 | `布尔值` | 如果为 true，则启用在解析器上拆分会按逗号拆分查询/正文/头参数。

例如，您可以使用它从查询参数解析多个值，如下所示：`/api?foo=bar,baz == foo[]=bar&foo[]=baz`

 | `false` |
| 启用受信任代理检查 | `布尔值` | 如果设置为 true，fiber 将使用受信任代理列表检查代理是否受信任。

默认情况下，`c.Protocol()` 将从 X-Forwarded-Proto、X-Forwarded-Protocol、X-Forwarded-Ssl 或 X-Url-Scheme 头获取值，`c.IP()` 将从 `ProxyHeader` 头获取值，`c.Hostname()` 将从 X-Forwarded-Host 头获取值。  
如果 `EnableTrustedProxyCheck` 为 true，并且 `RemoteIP` 在 `TrustedProxies` `c.Protocol()`、`c.IP()` 和 `c.Hostname()` 的列表中，则在禁用 `EnableTrustedProxyCheck` 时将具有相同行为，如果 `RemoteIP` 不在列表中，则 `c.Protocol()` 将在应用程序处理 tls 连接时返回 https，否则返回 http，`c.IP()` 将从 fasthttp 上下文中返回 RemoteIP()，`c.Hostname()` 将返回 `fasthttp.Request.URI().Host()`

 | `false` |
| 错误处理程序 | `错误处理程序` | 当从 fiber.Handler 返回错误时，将执行 ErrorHandler。由顶级应用程序保留已安装的 fiber 错误处理程序，并将其应用于关联的前缀请求。 | `DefaultErrorHandler` |
| GETOnly | `布尔值` | 如果设置为 true，则拒绝所有非 GET 请求。此选项可用作仅接受 GET 请求的服务器的抗 DoS 保护。如果设置了 GETOnly，则请求大小受 ReadBufferSize 限制。 | `false` |
| IdleTimeout | `time.Duration` | 启用 Keep-Alive 时等待下一个请求的最长时间。如果 IdleTimeout 为零，则使用 ReadTimeout 的值。 | `nil` |
| Immutable | `布尔值` | 启用后，context 方法返回的所有值都是不可变的。默认情况下，它们在您从处理程序返回之前有效；请参阅问题 [#185](https://github.com/gofiber/fiber/issues/185)。 | `false` |
| JSONDecoder | `utils.JSONUnmarshal` | 允许灵活地使用另一个 json 库进行解码。 | `json.Unmarshal` |
| JSONEncoder | `utils.JSONMarshal` | 允许灵活地使用另一个 json 库进行编码。 | `json.Marshal` |
| Network | `字符串` | 已知的网络有“tcp”、“tcp4”（仅限 IPv4）、“tcp6”（仅限 IPv6）

**警告：**当 prefork 设置为 true 时，只能选择“tcp4”和“tcp6”。

 | `NetworkTCP4` |
| PassLocalsToViews | `布尔值` | PassLocalsToViews 允许将 fiber.Ctx 上设置的本地变量传递到模板引擎。请参阅我们的**模板中间件**以了解支持的引擎。 | `false` |
| Prefork | `布尔值` | 启用[`SO_REUSEPORT`](https://lwn.net/Articles/542629/)套接字选项。这将生成多个在同一端口上侦听的 Go 进程。详细了解[套接字分片](https://www.nginx.com/blog/socket-sharding-nginx-release-1-9-1/)。**注意：如果启用，则需要通过 shell 运行应用程序，因为 prefork 模式会设置环境变量。如果您使用的是 Docker，请确保使用 `CMD ./app` 或 `CMD ["sh", "-c", "/app"]` 运行应用程序。有关更多信息，请参阅** [**此**](https://github.com/gofiber/fiber/issues/1021#issuecomment-730537971) **问题评论。** | `false` |
| ProxyHeader | `字符串` | 这将使 `c.IP()` 返回给定标头键的值。默认情况下，`c.IP()` 将返回 TCP 连接的远程 IP，如果您位于负载均衡器后面，此属性可能很有用，例如 *X-Forwarded-\**。 | `""` |
| ReadBufferSize | `整数` | 用于读取请求的每个连接的缓冲区大小。这也限制了最大标头大小。如果您的客户端发送多 KB 的 RequestURI 和/或多 KB 的标头（例如，大 Cookie），请增加此缓冲区。 | `4096` |
| ReadTimeout | `time.Duration` | 允许读取完整请求（包括正文）的时间量。默认超时时间无限制。 | `nil` |
| RequestMethods | `[]string` | RequestMethods 提供 HTTP 方法的可定制性。您可以根据需要添加/删除方法。 | `DefaultMethods` |
| ServerHeader | `字符串` | 使用给定值启用 `Server` HTTP 标头。 | `""` |
| StreamRequestBody | `布尔值` | StreamRequestBody 启用请求正文流式传输，并在给定正文大于当前限制时尽早调用处理程序。 | `false` |
| StrictRouting | `布尔值` | 启用后，路由器将 `/foo` 和 `/foo/` 视为不同的内容。否则，路由器将 `/foo` 和 `/foo/` 视为相同的内容。 | `false` |
| TrustedProxies | `[]string` | 包含受信任代理 IP 的列表。请参阅 `EnableTrustedProxyCheck` 文档。

它可以获取 IP 或 IP 范围地址。如果它获取 IP 范围，它将迭代所有可能的地址。

 | `[]string*__*` |
| UnescapePath | `布尔值` | 在为上下文设置路径之前，将路由中的所有编码字符转换回来，以便路由也可以处理 URL 编码的特殊字符 | `false` |
| Views | `Views` | Views 是包装 Render 函数的接口。有关受支持的引擎，请参阅我们的**模板中间件**。 | `nil` |
| ViewsLayout | `字符串` | Views Layout 是所有模板渲染的全局布局，直到在 Render 函数中覆盖。有关受支持的引擎，请参阅我们的**模板中间件**。 | `""` |
| WriteBufferSize | `整数` | 用于响应写入的每个连接的缓冲区大小。 | `4096` |
| WriteTimeout | `time.Duration` | 在响应写入超时前的最长时间。默认超时时间不限。 | `nil` |
| XMLEncoder | `utils.XMLMarshal` | 允许灵活使用其他 XML 库进行编码。 | `xml.Marshal` |

## NewError[](#newerror "Direct link to NewError")

NewError 创建一个新的 HTTPError 实例，并附带一个可选消息。

签名

```go
func NewError(code int, message ...string) *Error
```

示例

```go
app.Get("/", func(c *fiber.Ctx) error {    return fiber.NewError(782, "Custom error message")})
```

## IsChild[](#ischild "Direct link to IsChild")

IsChild 确定当前进程是否是 Prefork 的结果。

示例

```go
// Prefork will spawn child processesapp := fiber.New(fiber.Config{    Prefork: true,})if !fiber.IsChild() {    fmt.Println("I'm the parent process")} else {    fmt.Println("I'm a child process")}// ...
```