## Node.js 创建第一个应用

在传统的 PHP 开发中，需要一个像 Apache 或 Nginx 这样的 HTTP 服务器，并且需要配置 mod\_php 或 php-cgi 来处理 PHP 脚本，从而生成动态内容，也就是说 PHP 依赖于外部的 HTTP 服务器来接收请求并提供 Web 页面。

Node.js 本身就内置了一个 HTTP 服务器模块，这意味着在使用 Node.js 开发时，开发者可以直接使用 Node.js 的 HTTP 模块来创建服务器，处理 HTTP 请求，并生成 Web 页面。因此，在 Node.js 中，Web 应用的逻辑和 HTTP 服务器的实现是紧密集成的，开发者不需要依赖于外部的 HTTP 服务器软件。

在我们创建 Node.js 第一个 "Hello, World!" 应用前，让我们先了解下 Node.js 应用是由哪几部分组成的：

+   **require 指令**：在 Node.js 中，使用 require 指令来加载和引入模块，引入的模块可以是内置模块，也可以是第三方模块或自定义模块。
    
+   **创建服务器：**服务器可以监听客户端的请求，类似于 Apache 、Nginx 等 HTTP 服务器。
    
+   **接收请求与响应请求** 服务器很容易创建，客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据。
    

* * *

## 创建 Node.js 应用

### 步骤一、使用 require 指令来加载和引入模块

语法格式如下：

```
const module = require('module-name');
```

其中，module-name 可以是一个文件路径（相对或绝对路径），也可以是一个模块名称，如果是一个模块名称，Node.js 会自动从 node\_modules 目录中查找该模块。

require 指令会返回被加载的模块的导出对象，可以通过该对象来访问模块中定义的属性和方法，如果模块中有多个导出对象，则可以使用解构赋值的方式来获取它们。

我们使用 **require** 指令来载入 http 模块，并将实例化的 HTTP 赋值给变量 http，实例如下:

```
var http = require("http");
```

### 步骤二、创建服务器

接下来我们使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 8888 端口。 函数通过 request, response 参数来接收和响应数据。

实例如下，在你项目的根目录下创建一个叫 server.js 的文件，并写入以下代码：

## 实例

var http \= require('http');

http.createServer(function (request, response) {

        // 发送 HTTP 头部  
        // HTTP 状态值: 200 : OK  
        // 内容类型: text/plain  
        response.writeHead(200, {'Content-Type': 'text/plain'});
    
        // 发送响应数据 "Hello World"  
        response.end('Hello World\\n');  
}).listen(8888);

// 终端打印如下信息  
console.log('Server running at http://127.0.0.1:8888/');

以上代码我们完成了一个可以工作的 HTTP 服务器。

使用 **node** 命令执行以上的代码：

```
node server.js
Server running at http://127.0.0.1:8888/
```

![](https://www.runoob.com/wp-content/uploads/2014/03/cmdrun.jpg)

接下来，打开浏览器访问 http://127.0.0.1:8888/，你会看到一个写着 "Hello World"的网页。

![](https://www.runoob.com/wp-content/uploads/2014/03/nodejs-helloworld.jpg)

**分析Node.js 的 HTTP 服务器：**

+   `const http = require('http');`：导入 Node.js 内置的 `http` 模块。
+   `http.createServer((req, res) => { ... });`：创建一个新的 HTTP 服务器，每次有请求时都会执行回调函数。
+   `res.writeHead(200, { 'Content-Type': 'text/plain' });`：设置响应状态码和内容类型。
+   `res.end('Hello World\n');`：结束响应并发送数据。
+   `server.listen(PORT, () => { ... });`：监听指定端口并在服务器启动后输出信息。

* * *

## Gif 实例演示

接下来我们通过 Gif 图为大家演示实例操作：

![](https://www.runoob.com/wp-content/uploads/2014/03/node-hello.gif)

* * *

## Node.js 的工作机制

Node.js 通过 V8 引擎执行 JavaScript 代码，使用 Node.js API 与操作系统交互，并通过 Libuv 处理异步 I/O 操作。事件循环和工作线程确保了 Node.js 的高效和非阻塞特性。

![](https://www.runoob.com/wp-content/uploads/2014/03/1704959020813.png)

+   **V8 JavaScript Engine**：这是 Node.js 的核心，负责执行 JavaScript 代码。V8 是 Chrome 浏览器的 JavaScript 引擎，它将 JavaScript 代码编译成机器码以提高执行效率。
    
+   **Node.js Bindings (Node API)**：这一层提供了一组 API，允许 JavaScript 代码与操作系统进行交互。这些 API 包括文件系统、网络、进程等操作。
    
+   **Libuv (Asynchronous I/O)**：Libuv 是一个跨平台的异步 I/O 库，它在 Node.js 下运行，用于处理文件系统、网络和进程等异步操作。Libuv 使用事件循环和工作线程来处理这些操作，而不会阻塞主线程。
    
+   **Event Loop**：这是 Node.js 的核心概念之一。事件循环不断检查事件队列，处理事件和执行回调函数。它确保了 Node.js 的非阻塞和事件驱动的特性。
    
+   **Event Queue**：事件队列用于存储即将处理的事件。当一个异步操作完成时，相关的回调函数会被放入事件队列中，等待事件循环处理。
    
+   **Worker Threads**：这些是用于处理阻塞操作的线程，如文件读写、网络请求等。它们允许 Node.js 在不阻塞主线程的情况下执行这些操作。
    
+   **Blocking Operation**：这些是可能阻塞线程的操作，如同步的文件读写。在 Node.js 中，这些操作通常被放在工作线程中执行，以避免阻塞事件循环。
    
+   **Execute Callback**：一旦一个异步操作完成，它的回调函数就会被执行。这是通过事件循环来管理的。