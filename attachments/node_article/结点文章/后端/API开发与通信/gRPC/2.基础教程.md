## 基础教程

gRPC 在 C++ 中的基本教程介绍。

本教程为 C++ 程序员提供了使用 gRPC 的基本介绍。

通过学习这个示例，您将学习如何

+   在 `.proto` 文件中定义服务。
+   使用协议缓冲区编译器生成服务器和客户端代码。
+   使用 C++ gRPC API 为您的服务编写一个简单的客户端和服务器。

它假设您已经阅读了 [gRPC 简介](https://grpc.org.cn/docs/what-is-grpc/introduction/) 并且熟悉 [协议缓冲区](https://protobuf.com.cn/overview)。请注意，本教程中的示例使用协议缓冲区语言的 proto3 版本：您可以在 [proto3 语言指南](https://protobuf.com.cn/programming-guides/proto3) 和 [C++ 生成的代码指南](https://protobuf.com.cn/reference/cpp/cpp-generated) 中找到更多信息。

### 为什么要使用 gRPC？

我们的示例是一个简单的路线地图应用程序，它允许客户端获取有关其路线上要素的信息，创建其路线的摘要，并与服务器和其他客户端交换路线信息（如交通更新）。

使用 gRPC，我们可以一次在 `.proto` 文件中定义我们的服务，并以 gRPC 支持的任何语言生成客户端和服务器，这些客户端和服务器又可以在从大型数据中心内的服务器到您自己的平板电脑的各种环境中运行 — 不同语言和环境之间通信的所有复杂性都由 gRPC 为您处理。我们还可以获得使用协议缓冲区的所有优势，包括高效的序列化、简单的 IDL 和简单的接口更新。

### 示例代码和设置

示例代码是 `grpc` 仓库的一部分，位于 [examples/cpp/route\_guide](https://github.com/grpc/grpc/tree/v1.66.0/examples/cpp/route_guide)。获取示例代码并构建 gRPC

1.  按照快速入门说明从源代码 [构建并在本地安装 gRPC](https://grpc.org.cn/docs/languages/cpp/quickstart/#install-grpc)。
    
2.  从仓库文件夹，更改到路线指南示例目录
    
    ```sh
    cd examples/cpp/route_guide
    ```
    
3.  运行 `cmake`
    
    ```sh
    mkdir -p cmake/build
    cd cmake/build
    cmake -DCMAKE_PREFIX_PATH=$MY_INSTALL_DIR ../..
    ```
    

### 定义服务

我们的第一步（正如您从 [gRPC 简介](https://grpc.org.cn/docs/what-is-grpc/introduction/) 中了解到的那样）是使用 [协议缓冲区](https://protobuf.com.cn/overview) 定义 gRPC *服务* 以及方法*请求*和*响应*类型。您可以在 [`examples/protos/route_guide.proto`](https://github.com/grpc/grpc/blob/v1.66.0/examples/protos/route_guide.proto) 中看到完整的 `.proto` 文件。

要定义服务，您需要在 `.proto` 文件中指定一个名为 `service` 的服务

```protobuf
service RouteGuide {
   ...
}
```

然后在您的服务定义中定义 `rpc` 方法，指定它们的请求和响应类型。gRPC 允许您定义四种服务方法，所有这些方法都在 `RouteGuide` 服务中使用

+   *简单 RPC*，其中客户端使用存根向服务器发送请求，并等待响应返回，就像正常的函数调用一样。
    
    ```protobuf
    // Obtains the feature at a given position.
    rpc GetFeature(Point) returns (Feature) {}
    ```
    
+   *服务器端流式 RPC*，其中客户端向服务器发送请求，并获取一个流以读取一系列返回的消息。客户端从返回的流中读取，直到没有更多消息为止。正如您在示例中看到的那样，您可以通过在*响应*类型之前放置 `stream` 关键字来指定服务器端流式方法。
    
    ```protobuf
    // Obtains the Features available within the given Rectangle.  Results are
    // streamed rather than returned at once (e.g. in a response message with a
    // repeated field), as the rectangle may cover a large area and contain a
    // huge number of features.
    rpc ListFeatures(Rectangle) returns (stream Feature) {}
    ```
    
+   *客户端流式 RPC*，其中客户端写入一系列消息并将它们发送到服务器，同样使用提供的流。一旦客户端完成写入消息，它将等待服务器读取所有消息并返回其响应。您可以通过在*请求*类型之前放置 `stream` 关键字来指定客户端流式方法。
    
    ```protobuf
    // Accepts a stream of Points on a route being traversed, returning a
    // RouteSummary when traversal is completed.
    rpc RecordRoute(stream Point) returns (RouteSummary) {}
    ```
    
+   *双向流式 RPC*，其中双方使用读写流发送一系列消息。两个流独立运行，因此客户端和服务器可以按照他们喜欢的任何顺序读取和写入：例如，服务器可以等待接收所有客户端消息，然后再写入其响应，或者它可以交替读取消息然后写入消息，或者其他读取和写入的组合。每个流中消息的顺序都会被保留。您可以通过在请求和响应之前都放置 `stream` 关键字来指定这种类型的方法。
    
    ```protobuf
    // Accepts a stream of RouteNotes sent while a route is being traversed,
    // while receiving other RouteNotes (e.g. from other users).
    rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}
    ```
    

我们的 `.proto` 文件还包含用于我们服务方法中使用的所有请求和响应类型的协议缓冲区消息类型定义 — 例如，这是 `Point` 消息类型

```protobuf
// Points are represented as latitude-longitude pairs in the E7 representation
// (degrees multiplied by 10**7 and rounded to the nearest integer).
// Latitudes should be in the range +/- 90 degrees and longitude should be in
// the range +/- 180 degrees (inclusive).
message Point {
  int32 latitude = 1;
  int32 longitude = 2;
}
```

### 生成客户端和服务器代码

接下来，我们需要从我们的 `.proto` 服务定义中生成 gRPC 客户端和服务器接口。我们使用带有特殊 gRPC C++ 插件的协议缓冲区编译器 `protoc` 来完成此操作。

为了简单起见，我们提供了一个 [CMakeLists.txt](https://github.com/grpc/grpc/blob/v1.66.0/examples/cpp/route_guide/CMakeLists.txt)，它会使用适当的插件、输入和输出为你运行 `protoc` （如果你想自己运行，请确保你已经安装了 protoc 并遵循了 gRPC 代码的 [安装说明](https://github.com/grpc/grpc/blob/v1.66.0/src/cpp/README.md#cmake)）。

```sh
make route_guide.grpc.pb.o
```

实际上运行的是

```sh
protoc -I ../../protos --grpc_out=. --plugin=protoc-gen-grpc=`which grpc_cpp_plugin` ../../protos/route_guide.proto
protoc -I ../../protos --cpp_out=. ../../protos/route_guide.proto
```

运行此命令会在当前目录中生成以下文件：

+   `route_guide.pb.h`，声明生成的消息类的头文件
+   `route_guide.pb.cc`，包含消息类的实现
+   `route_guide.grpc.pb.h`，声明生成的服务类的头文件
+   `route_guide.grpc.pb.cc`，包含服务类的实现

这些文件包含

+   所有用于填充、序列化和检索我们的请求和响应消息类型的协议缓冲区代码
    
+   一个名为 `RouteGuide` 的类，其中包含
    
    +   客户端调用 `RouteGuide` 服务中定义的方法的远程接口类型（或*存根*）。
    +   两个供服务器实现的抽象接口，也包含 `RouteGuide` 服务中定义的方法。

### 创建服务器

首先，让我们看看如何创建 `RouteGuide` 服务器。如果你只对创建 gRPC 客户端感兴趣，可以跳过此部分，直接阅读[创建客户端](#client)（不过你可能会觉得这部分也很有趣！）。

要使我们的 `RouteGuide` 服务正常工作，需要完成两部分工作：

+   实现从我们的服务定义生成的服务接口：执行我们服务的实际“工作”。
+   运行 gRPC 服务器以监听来自客户端的请求并返回服务响应。

你可以在 [examples/cpp/route\_guide/route\_guide\_server.cc](https://github.com/grpc/grpc/blob/v1.66.0/examples/cpp/route_guide/route_guide_server.cc) 中找到我们的示例 `RouteGuide` 服务器。让我们仔细看看它的工作原理。

#### 实现 RouteGuide

如你所见，我们的服务器有一个 `RouteGuideImpl` 类，它实现了生成的 `RouteGuide::Service` 接口。

```cpp
class RouteGuideImpl final : public RouteGuide::Service {
...
}
```

在这种情况下，我们正在实现 `RouteGuide` 的*同步*版本，它提供了我们的默认 gRPC 服务器行为。也可以实现异步接口 `RouteGuide::AsyncService`，它允许你进一步自定义服务器的线程行为，但我们不会在本教程中讨论它。

`RouteGuideImpl` 实现了我们所有的服务方法。让我们先看看最简单的类型 `GetFeature`，它只是从客户端获取一个 `Point`，并从其数据库中返回相应的要素信息，放入一个 `Feature` 中。

```cpp
Status GetFeature(ServerContext* context, const Point* point,
                  Feature* feature) override {
  feature->set_name(GetFeatureName(*point, feature_list_));
  feature->mutable_location()->CopyFrom(*point);
  return Status::OK;
}
```

该方法会传递一个 RPC 的上下文对象、客户端的 `Point` 协议缓冲区请求和一个 `Feature` 协议缓冲区，用于填充响应信息。在该方法中，我们用适当的信息填充 `Feature`，然后 `return` 一个 `OK` 状态，以告知 gRPC 我们已完成对 RPC 的处理，并且 `Feature` 可以返回给客户端。

请注意，所有服务方法都可以（并且将会！）同时从多个线程调用。你必须确保你的方法实现是线程安全的。在我们的示例中，`feature_list_` 在构造后永远不会更改，因此在设计上是安全的。但是，如果 `feature_list_` 在服务的生命周期中发生更改，我们将需要同步对该成员的访问。

现在让我们看看更复杂一些的内容 - 流式 RPC。 `ListFeatures` 是服务器端流式 RPC，因此我们需要向客户端发回多个 `Feature`。

```cpp
Status ListFeatures(ServerContext* context, const Rectangle* rectangle,
                    ServerWriter<Feature>* writer) override {
  auto lo = rectangle->lo();
  auto hi = rectangle->hi();
  long left = std::min(lo.longitude(), hi.longitude());
  long right = std::max(lo.longitude(), hi.longitude());
  long top = std::max(lo.latitude(), hi.latitude());
  long bottom = std::min(lo.latitude(), hi.latitude());
  for (const Feature& f : feature_list_) {
    if (f.location().longitude() >= left &&
        f.location().longitude() <= right &&
        f.location().latitude() >= bottom &&
        f.location().latitude() <= top) {
      writer->Write(f);
    }
  }
  return Status::OK;
}
```

如你所见，在我们的方法参数中，我们这次没有获得简单的请求和响应对象，而是获得了一个请求对象（客户端想要在其中查找 `Feature` 的 `Rectangle`）和一个特殊的 `ServerWriter` 对象。在该方法中，我们填充我们需要返回的尽可能多的 `Feature` 对象，并使用其 `Write()` 方法将它们写入 `ServerWriter`。最后，就像我们的简单 RPC 中一样，我们 `return Status::OK` 以告知 gRPC 我们已完成写入响应。

如果你查看客户端流式方法 `RecordRoute`，你会发现它非常相似，只是这次我们获得了一个 `ServerReader` 而不是请求对象和一个单独的响应。我们使用 `ServerReader` 的 `Read()` 方法重复读取客户端的请求到一个请求对象（在本例中为 `Point`），直到没有更多消息：服务器需要在每次调用后检查 `Read()` 的返回值。如果为 `true`，则流仍然良好，它可以继续读取；如果为 `false`，则消息流已结束。

```cpp
while (stream->Read(&point)) {
  ...//process client input
}
```

最后，让我们看看我们的双向流式 RPC `RouteChat()`。

```cpp
Status RouteChat(ServerContext* context,
                  ServerReaderWriter<RouteNote, RouteNote>* stream) override {
  RouteNote note;
  while (stream->Read(&note)) {
    std::unique_lock<std::mutex> lock(mu_);
    for (const RouteNote& n : received_notes_) {
      if (n.location().latitude() == note.location().latitude() &&
          n.location().longitude() == note.location().longitude()) {
        stream->Write(n);
      }
    }
    received_notes_.push_back(note);
  }

  return Status::OK;
}
```

这次我们获得了一个 `ServerReaderWriter`，它可以用于读取*和*写入消息。此处的读取和写入语法与我们的客户端流式和服务器端流式方法完全相同。尽管每一方总是按照写入顺序接收对方的消息，但客户端和服务器都可以以任意顺序读取和写入 - 流的运行完全独立。

请注意，由于 `received_notes_` 是一个实例变量，并且可以被多个线程访问，因此我们在此处使用互斥锁来保证独占访问。

#### 启动服务器

一旦我们实现了所有方法，我们还需要启动一个 gRPC 服务器，以便客户端可以实际使用我们的服务。以下代码片段展示了我们如何为 `RouteGuide` 服务执行此操作：

```cpp
void RunServer(const std::string& db_path) {
  std::string server_address("0.0.0.0:50051");
  RouteGuideImpl service(db_path);

  ServerBuilder builder;
  builder.AddListeningPort(server_address, grpc::InsecureServerCredentials());
  builder.RegisterService(&service);
  std::unique_ptr<Server> server(builder.BuildAndStart());
  std::cout << "Server listening on " << server_address << std::endl;
  server->Wait();
}
```

如你所见，我们使用 `ServerBuilder` 构建并启动服务器。为此，我们：

1.  创建服务实现类 `RouteGuideImpl` 的实例。
2.  创建工厂类 `ServerBuilder` 的实例。
3.  使用构建器的 `AddListeningPort()` 方法指定我们要用于侦听客户端请求的地址和端口。
4.  向构建器注册我们的服务实现。
5.  调用构建器的 `BuildAndStart()` 以创建并启动我们服务的 RPC 服务器。
6.  调用服务器的 `Wait()` 以执行阻塞等待，直到进程被终止或调用 `Shutdown()`。

### 创建客户端

在本节中，我们将了解如何为我们的 `RouteGuide` 服务创建 C++ 客户端。你可以在 [examples/cpp/route\_guide/route\_guide\_client.cc](https://github.com/grpc/grpc/blob/v1.66.0/examples/cpp/route_guide/route_guide_client.cc) 中查看我们完整的示例客户端代码。

#### 创建存根

要调用服务方法，我们首先需要创建一个*存根*。

首先，我们需要为我们的存根创建一个 gRPC *通道*，指定我们要连接的服务器地址和端口 - 在我们的例子中，我们将不使用 SSL。

```cpp
grpc::CreateChannel("localhost:50051", grpc::InsecureChannelCredentials());
```

#### 注意：

要为 *通道* 设置其他选项，请使用带有任何特殊通道参数 - `grpc::ChannelArguments` 的 `grpc::CreateCustomChannel()` api。

现在，我们可以使用该通道，利用我们从 `.proto` 生成的 `RouteGuide` 类中提供的 `NewStub` 方法来创建我们的存根。

```cpp
public:
 RouteGuideClient(std::shared_ptr<ChannelInterface> channel,
                  const std::string& db)
     : stub_(RouteGuide::NewStub(channel)) {
   ...
 }
```

#### 调用服务方法

现在让我们看看如何调用我们的服务方法。请注意，在本教程中，我们调用的是每个方法的*阻塞/同步*版本：这意味着 RPC 调用会等待服务器响应，并且要么返回响应，要么引发异常。

##### 简单 RPC

调用简单的 RPC `GetFeature` 几乎和调用本地方法一样直接。

```cpp
Point point;
Feature feature;
point = MakePoint(409146138, -746188906);
GetOneFeature(point, &feature);

...

bool GetOneFeature(const Point& point, Feature* feature) {
  ClientContext context;
  Status status = stub_->GetFeature(&context, point, feature);
  ...
}
```

如你所见，我们创建并填充一个请求协议缓冲区对象（在我们的例子中是 `Point`），并创建一个响应协议缓冲区对象，供服务器填充。我们还为我们的调用创建了一个 `ClientContext` 对象 - 你可以选择在此对象上设置 RPC 配置值，例如截止时间，但现在我们将使用默认设置。请注意，你不能在调用之间重用此对象。最后，我们调用 stub 上的方法，并将上下文、请求和响应传递给它。如果该方法返回 `OK`，那么我们可以从我们的响应对象中读取服务器的响应信息。

```cpp
std::cout << "Found feature called " << feature->name()  << " at "
          << feature->location().latitude()/kCoordFactor_ << ", "
          << feature->location().longitude()/kCoordFactor_ << std::endl;
```

##### 流式 RPC

现在让我们看看我们的流式方法。如果你已经阅读过[创建服务器](#server)，那么其中一些内容看起来可能会很熟悉 - 流式 RPC 在双方的实现方式类似。以下是我们调用服务器端流式方法 `ListFeatures` 的地方，它返回一个地理 `Feature` 流

```cpp
std::unique_ptr<ClientReader<Feature> > reader(
    stub_->ListFeatures(&context, rect));
while (reader->Read(&feature)) {
  std::cout << "Found feature called "
            << feature.name() << " at "
            << feature.location().latitude()/kCoordFactor_ << ", "
            << feature.location().longitude()/kCoordFactor_ << std::endl;
}
Status status = reader->Finish();
```

我们不是向方法传递上下文、请求和响应，而是向其传递上下文和请求，并获得一个 `ClientReader` 对象。客户端可以使用 `ClientReader` 读取服务器的响应。我们使用 `ClientReader` 的 `Read()` 方法重复读取服务器对响应协议缓冲区对象（在本例中为 `Feature`）的响应，直到没有更多消息：客户端需要在每次调用后检查 `Read()` 的返回值。如果为 `true`，则流仍然良好，可以继续读取；如果为 `false`，则消息流已结束。最后，我们在流上调用 `Finish()` 以完成调用并获取我们的 RPC 状态。

客户端流式方法 `RecordRoute` 类似，不同之处在于，我们向方法传递上下文和响应对象，并返回一个 `ClientWriter`。

```cpp
std::unique_ptr<ClientWriter<Point> > writer(
    stub_->RecordRoute(&context, &stats));
for (int i = 0; i < kPoints; i++) {
  const Feature& f = feature_list_[feature_distribution(generator)];
  std::cout << "Visiting point "
            << f.location().latitude()/kCoordFactor_ << ", "
            << f.location().longitude()/kCoordFactor_ << std::endl;
  if (!writer->Write(f.location())) {
    // Broken stream.
    break;
  }
  std::this_thread::sleep_for(std::chrono::milliseconds(
      delay_distribution(generator)));
}
writer->WritesDone();
Status status = writer->Finish();
if (status.IsOk()) {
  std::cout << "Finished trip with " << stats.point_count() << " points\n"
            << "Passed " << stats.feature_count() << " features\n"
            << "Travelled " << stats.distance() << " meters\n"
            << "It took " << stats.elapsed_time() << " seconds"
            << std::endl;
} else {
  std::cout << "RecordRoute rpc failed." << std::endl;
}
```

一旦我们使用 `Write()` 完成了将客户端请求写入流的操作，我们需要在流上调用 `WritesDone()`，以告知 gRPC 我们已完成写入，然后调用 `Finish()` 以完成调用并获取我们的 RPC 状态。如果状态为 `OK`，则我们最初传递给 `RecordRoute()` 的响应对象将被服务器的响应填充。

最后，让我们看看我们的双向流式 RPC `RouteChat()`。在这种情况下，我们只需向方法传递一个上下文，并返回一个 `ClientReaderWriter`，我们可以使用它来写入和读取消息。

```cpp
std::shared_ptr<ClientReaderWriter<RouteNote, RouteNote> > stream(
    stub_->RouteChat(&context));
```

此处读取和写入的语法与我们的客户端流式和服务器流式方法的语法完全相同。尽管每一方都会按照写入的顺序获取对方的消息，但客户端和服务器都可以按任何顺序读取和写入 - 流是完全独立运行的。

### 试试看！

构建客户端和服务器

运行服务器

```sh
./route_guide_server --db_path=path/to/route_guide_db.json
```

从不同的终端，运行客户端

```sh
./route_guide_client --db_path=path/to/route_guide_db.json
```