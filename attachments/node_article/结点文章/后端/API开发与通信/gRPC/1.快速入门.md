## 快速入门

本指南通过一个简单的工作示例，让您开始在 C++ 中使用 gRPC。

在 C++ 世界中，没有一个普遍接受的项目依赖管理标准。您需要在构建和运行本快速入门的 Hello World 示例之前，构建和安装 gRPC。

### 构建并在本地安装 gRPC 和 Protocol Buffers

本节中的步骤说明了如何使用 `cmake` 构建并在本地安装 gRPC 和 Protocol Buffers。如果您更喜欢使用 [bazel](https://www.bazel.build/)，请参阅 [从源代码构建](https://github.com/grpc/grpc/blob/master/BUILDING.md#build-from-source)。

#### 设置

选择一个目录来保存本地安装的软件包。此页面假设环境变量 `MY_INSTALL_DIR` 保存此目录路径。例如

+   Linux / macOS

```sh
export MY_INSTALL_DIR=$HOME/.local
```

确保该目录存在

将本地 `bin` 文件夹添加到您的路径变量中，例如

```sh
export PATH="$MY_INSTALL_DIR/bin:$PATH"
```

+   Windows

```powershell
set MY_INSTALL_DIR=%USERPROFILE%\cmake
```

确保该目录存在

将本地 `bin` 文件夹添加到您的路径变量中，例如

```powershell
set PATH=%PATH%;$MY_INSTALL_DIR\bin
```

#### 安装 cmake

您需要 3.16 或更高版本的 `cmake`。如果您没有，请按照这些说明进行安装

+   Linux
    
    ```sh
    sudo apt install -y cmake
    ```
    
+   macOS
    
+   Windows
    
+   有关通用的 `cmake` 安装说明，请参阅 [安装 CMake](https://cmake.com.cn/install)。
    

检查 `cmake` 的版本

```sh
cmake --version
cmake version 3.30.3
```

在 Linux 下，系统范围的 `cmake` 版本通常可能太旧。您可以按照以下步骤将更新的版本安装到本地安装目录中

```sh
wget -q -O cmake-linux.sh https://github.com/Kitware/CMake/releases/download/v3.30.3/cmake-3.30.3-linux-x86_64.sh
sh cmake-linux.sh -- --skip-license --prefix=$MY_INSTALL_DIR
rm cmake-linux.sh
```

#### 安装其他所需工具

安装构建 gRPC 所需的基本工具

+   Linux
    
    ```sh
    sudo apt install -y build-essential autoconf libtool pkg-config
    ```
    
+   macOS
    
    ```sh
    brew install autoconf automake libtool pkg-config
    ```
    

#### 克隆 `grpc` 仓库

克隆 `grpc` 仓库及其子模块

```sh
git clone --recurse-submodules -b v1.66.0 --depth 1 --shallow-submodules https://github.com/grpc/grpc
```

#### 构建并安装 gRPC 和 Protocol Buffers

虽然不是强制性的，但 gRPC 应用程序通常利用 [Protocol Buffers](https://developers.google.com/protocol-buffers) 进行服务定义和数据序列化，并且示例代码使用 [proto3](https://protobuf.com.cn/programming-guides/proto3)。

以下命令构建并在本地安装 gRPC 和 Protocol Buffers

+   Linux & macOS
    
    ```sh
    cd grpc
    mkdir -p cmake/build
    pushd cmake/build
    cmake -DgRPC_INSTALL=ON \
          -DgRPC_BUILD_TESTS=OFF \
          -DCMAKE_CXX_STANDARD=17 \
          -DCMAKE_INSTALL_PREFIX=$MY_INSTALL_DIR \
          ../..
    make -j 4
    make install
    popd
    ```
    
+   Windows
    
    ```powershell
    mkdir "cmake\build"
    pushd "cmake\build"
    cmake -DgRPC_INSTALL=ON -DgRPC_BUILD_TESTS=OFF -DCMAKE_CXX_STANDARD=17 -DCMAKE_INSTALL_PREFIX=%MY_INSTALL_DIR% ..\..
    cmake --build . --config Release --target install -j 4
    popd
    ```
    

#### 重要提示

我们**强烈**建议您*本地*安装 gRPC — 使用适当设置的 `CMAKE_INSTALL_PREFIX` — 因为全局安装 gRPC 后没有简单的方法卸载它。

更多信息

+   您可以在 [从源代码构建](https://github.com/grpc/grpc/blob/master/BUILDING.md#build-from-source) 中找到构建 gRPC C++ 的完整说明。
+   有关如何将 gRPC 作为依赖项添加到 C++ 项目的一般说明，请参阅 [开始使用 gRPC C++](https://github.com/grpc/grpc/tree/master/src/cpp#to-start-using-grpc-c)。

### 构建示例

示例代码是您在上一节步骤中克隆的 `grpc` 仓库源代码的一部分。

1.  切换到示例的目录
    
    ```sh
    cd examples/cpp/helloworld
    ```
    
2.  使用 `cmake` 构建示例
    
    +   Linux & macOS
        
        ```sh
        mkdir -p cmake/build
        pushd cmake/build
        cmake -DCMAKE_PREFIX_PATH=$MY_INSTALL_DIR ../..
        make -j 4
        ```
        
    +   Windows
        
        ```powershell
        mkdir "cmake\build"
        pushd "cmake\build"
        cmake -DCMAKE_INSTALL_PREFIX=%MY_INSTALL_DIR% ..\..
        cmake --build . --config Release -j 4
        popd
        ```
        
    
    #### 注意
    
    **构建失败？** 在此阶段，大多数问题都是安装错误造成的。请确保您拥有正确版本的 `cmake`，并仔细重新检查您的安装。
    

### 尝试一下！

从示例**构建**目录 `examples/cpp/helloworld/cmake/build` 运行示例

1.  运行服务器
    
2.  从不同的终端，运行客户端并查看客户端输出
    
    ```sh
    ./greeter_client
    Greeter received: Hello world
    ```
    

恭喜！您刚刚使用 gRPC 运行了一个客户端-服务器应用程序。

### 更新 gRPC 服务

现在，让我们看看如何更新应用程序，在服务器上添加一个额外的方法供客户端调用。我们的 gRPC 服务是使用 protocol buffers 定义的；您可以在[gRPC 简介](https://grpc.org.cn/docs/what-is-grpc/introduction/)和[基础教程](https://grpc.org.cn/docs/languages/cpp/basics/)中了解更多关于如何在 `.proto` 文件中定义服务的信息。现在您只需要知道服务器和客户端存根都有一个 `SayHello()` RPC 方法，该方法从客户端获取一个 `HelloRequest` 参数，并从服务器返回一个 `HelloReply`，并且此方法定义如下

```protobuf
// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply) {}
}

// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings
message HelloReply {
  string message = 1;
}
```

打开 [examples/protos/helloworld.proto](https://github.com/grpc/grpc/blob/v1.66.0/examples/protos/helloworld.proto) 并添加一个新的 `SayHelloAgain()` 方法，使用相同的请求和响应类型

```protobuf
// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply) {}
  // Sends another greeting
  rpc SayHelloAgain (HelloRequest) returns (HelloReply) {}
}

// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings
message HelloReply {
  string message = 1;
}
```

请记住保存文件！

### 重新生成 gRPC 代码

在您可以使用新的服务方法之前，您需要重新编译更新的 proto 文件。

从示例**构建**目录 `examples/cpp/helloworld/cmake/build` 中运行

+   Linux & macOS

+   Windows

```powershell
cmake --build . --config Release -j 4
```

这将重新生成 `helloworld.pb.{h,cc}` 和 `helloworld.grpc.pb.{h,cc}`，其中包含生成的客户端和服务器类，以及用于填充、序列化和检索我们的请求和响应类型的类。

### 更新并运行应用程序

您拥有了新生成的服务器和客户端代码，但您仍然需要在我们示例应用程序的手写部分中实现并调用新方法。

#### 更新服务器

从示例的根目录打开 `greeter_server.cc`。像这样实现新方法

```c++
class GreeterServiceImpl final : public Greeter::Service {
  Status SayHello(ServerContext* context, const HelloRequest* request,
                  HelloReply* reply) override {
     // ...
  }

  Status SayHelloAgain(ServerContext* context, const HelloRequest* request,
                       HelloReply* reply) override {
    std::string prefix("Hello again ");
    reply->set_message(prefix + request->name());
    return Status::OK;
  }
};
```

#### 更新客户端

现在，stub 中提供了一个新的 `SayHelloAgain()` 方法。我们将遵循与已经存在的 `SayHello()` 相同的模式，并向 `GreeterClient` 添加一个新的 `SayHelloAgain()` 方法

```c++
class GreeterClient {
 public:
  // ...
  std::string SayHello(const std::string& user) {
     // ...
  }

  std::string SayHelloAgain(const std::string& user) {
    // Follows the same pattern as SayHello.
    HelloRequest request;
    request.set_name(user);
    HelloReply reply;
    ClientContext context;

    // Here we can use the stub's newly available method we just added.
    Status status = stub_->SayHelloAgain(&context, request, &reply);
    if (status.ok()) {
      return reply.message();
    } else {
      std::cout << status.error_code() << ": " << status.error_message()
                << std::endl;
      return "RPC failed";
    }
  }
```

最后，在 `main()` 中调用这个新方法

```c++
int main(int argc, char** argv) {
  // ...
  std::string reply = greeter.SayHello(user);
  std::cout << "Greeter received: " << reply << std::endl;

  reply = greeter.SayHelloAgain(user);
  std::cout << "Greeter received: " << reply << std::endl;

  return 0;
}
```

#### 运行！

像之前一样运行客户端和服务器。从示例的 **build** 目录 `examples/cpp/helloworld/cmake/build` 执行以下命令

1.  在进行更改后，构建客户端和服务器
    
    +   Linux & macOS
    
    +   Windows
    
    ```powershell
    cmake --build . --config Release -j 4
    ```
    
2.  运行服务器
    
3.  在不同的终端上，运行客户端
    
    您将看到以下输出
    
    ```nocode
    Greeter received: Hello world
    Greeter received: Hello again world
    ```
    

#### 注意

对客户端和服务器的**异步**版本感兴趣吗？您可以在 [示例的源代码目录](https://github.com/grpc/grpc/tree/master/examples/cpp/helloworld) 中找到 `greeter_async_{client,server}.cc` 文件。

### 下一步

+   了解 gRPC 的工作原理，请参阅 [gRPC 简介](https://grpc.org.cn/docs/what-is-grpc/introduction/) 和 [核心概念](https://grpc.org.cn/docs/what-is-grpc/core-concepts/)。
+   完成 [基础教程](https://grpc.org.cn/docs/languages/cpp/basics/)。
+   浏览 [API 参考](https://grpc.org.cn/docs/languages/cpp/api)。